import re

GRADING_MARKER = '### Grading:'

REPORT_FILE_NAME = 'grading_report.txt'
SUMMARY_FILE_NAME = 'grading_summary.csv'

REPORT_PREAMBLE = """ Automatically Generated Grading Report

The instructor has read and evaluated your Python files. Grading comments 
have been added to the Python files as comments starting with the 
marker '### Grading:'. For convenience, all grading comments have been 
collected into this automatically generated grading report -- 
But to understand each comment, you will need to look in the individual 
Python files So that you can see the context for each comment.

This automatically generated report also includes a summary of the scores 
awarded for each question and each Python file, with a grand total of your 
overall score on the lab exam at the bottom.

The grading comments are produced by a largely manual process but with some 
AI assistance. All numerical scores for questions are entered manually. 
Sometimes, the whole or part of an explanatory comment is generated by an AI 
assistant, but every comment is reviewed and edited if necessary by the instructor.

Here are your grading comments and scores:

"""


def extract_grading_comments_from_file(file_name):
    """
    Extract grading comments from a specified file.

    This function reads a file containing grading comments and extracts
    the relevant information for further processing.

    Returns:
        list: A list of grading comments extracted from the file.
    """
    grading_comments = []

    try:
        with open(file_name, 'r', encoding='utf-8') as file:
            for line in file:
                line_text = line.strip()
                if line_text:
                    if GRADING_MARKER in line_text:
                        # Extract the comment after the grading marker, but including the marker itself
                        extracted = line_text[line_text.index(
                            GRADING_MARKER):].strip()
                        grading_comments.append(extracted)
    except FileNotFoundError:
        print(f"The file '{file_name}' was not found.")
    except OSError as e:
        print(f"An I/O error occurred while reading '{file_name}': {e}")

    return grading_comments


def compute_score_totals(grading_comments):
    """
    Compute total obtained and total possible scores from grading comments.

    Args:
        grading_comments (list[str]): list of comment strings (each usually
            starting with the GRADING_MARKER).

    Returns:
        tuple: (total_obtained, total_possible) as integers. If no matches are
            found both values are 0.

    Notes:
        This function looks for occurrences of the pattern
        "<GRADING_MARKER> <obtained>/<possible>" inside each comment. It
        supports multiple matches in a single comment (all are summed).
    """
    total_obtained = 0
    total_possible = 0

    # Build a regex that requires the GRADING_MARKER before the score pair.
    # We use a non-capturing group for repeated scanning; findall returns the
    # captured groups (obtained, possible).
    pattern = re.compile(re.escape(GRADING_MARKER) + r"\s*(\d+)\s*/\s*(\d+)")

    for c in grading_comments:
        # Find all (obtained, possible) pairs that directly follow the marker
        matches = pattern.findall(c)
        for obtained_str, possible_str in matches:
            try:
                obt = int(obtained_str)
                pos = int(possible_str)
            except ValueError:
                # skip values that aren't integers
                continue
            total_obtained += obt
            total_possible += pos

    return total_obtained, total_possible


def compute_totals_in_directory(directory_path, recursive=False, report_per_file=False, write_report=False, write_summary=False):
    """
    Scan Python files in `directory_path` and compute summed scores.

    Args:
        directory_path (str): path to directory to scan for .py files.
        recursive (bool): if True, walk subdirectories recursively. Default False.

    Returns:
        tuple: (total_obtained, total_possible) summed across all .py files found.
    """
    import os

    total_obtained = 0
    total_possible = 0

    if recursive:
        walker = os.walk(directory_path)
    else:
        # single directory listing
        try:
            entries = [(directory_path, [], [f for f in os.listdir(
                directory_path) if os.path.isfile(os.path.join(directory_path, f))])]
            walker = entries
        except OSError as e:
            print(f"Could not list directory '{directory_path}': {e}")
            return 0, 0

    # Store per-file tuples: (comments_list, (obtained, possible))
    per_file_results = {}

    for root, _dirs, files in walker:
        for name in files:
            if name.endswith('.py'):
                path = os.path.join(root, name)
                try:
                    file_comments = extract_grading_comments_from_file(path)
                except OSError as e:
                    # If a single file fails to read/parse, continue with others
                    print(f"Skipping '{path}' due to I/O error: {e}")
                    continue
                obt, pos = compute_score_totals(file_comments)
                total_obtained += obt
                total_possible += pos
                if report_per_file or write_report:
                    per_file_results[path] = (file_comments, (obt, pos))

    # If requested, write a report file into the directory_path (non-recursive)
    # or into each directory encountered when recursive.
    if write_report:
        # Determine which directories to write reports for. If recursive, write
        # for every directory that had any .py files processed. Otherwise only
        # write for the provided directory_path.
        dirs_to_report = set()
        if recursive:
            for filepath in per_file_results:
                dirs_to_report.add(os.path.dirname(filepath))
        else:
            dirs_to_report.add(directory_path)

        for d in sorted(dirs_to_report):
            report_path = os.path.join(d, REPORT_FILE_NAME)
            try:
                with open(report_path, 'w', encoding='utf-8') as rpt:
                    print(f"Writing report to '{report_path}'")
                    # Prepend the REPORT_PREAMBLE for context
                    rpt.write(REPORT_PREAMBLE)
                    rpt.write(f"Grading report for directory: {os.path.basename(d)}\n")
                    rpt.write("\n")
                    grand_obt = 0
                    grand_pos = 0
                    # Collect files in this directory in a stable order
                    files_in_dir = [p for p in sorted(
                        per_file_results) if os.path.dirname(p) == d]
                    for p in files_in_dir:
                        comments_list, (fobt, fpos) = per_file_results[p]
                        rpt.write(f"File: {os.path.basename(p)}\n")
                        for c in comments_list:
                            rpt.write(c + "\n")
                        rpt.write(
                            f"Total for {os.path.basename(p)}: {fobt} / {fpos}\n")
                        rpt.write("\n")
                        grand_obt += fobt
                        grand_pos += fpos
                    rpt.write(f"Grand total: {grand_obt} / {grand_pos}\n")
            except OSError as e:
                print(f"Could not write report to '{report_path}': {e}")

    # If requested, and running in recursive mode, build a CSV summary at the
    # top-level scanned directory. The CSV will have three columns: a directory
    # name, the grand total of obtained scores for that directory, and the grand total of possible scores. The
    # grand total for a directory includes totals from all its subdirectories
    # (recursive sum).
    if recursive and write_summary:
        # Build per-directory own totals (sum of files directly in that dir)
        dir_own = {}
        dir_own_possible = {}
        for filepath, (comments_list, (fobt, fpos)) in per_file_results.items():
            d = os.path.dirname(filepath)
            dir_own[d] = dir_own.get(d, 0) + fobt
            dir_own_possible[d] = dir_own_possible.get(d, 0) + fpos

        # Gather all directories under the top-level directory_path (including
        # the top-level itself) so we can include directories even with no
        # immediate files. Use os.walk for stability and deterministic order.
        all_dirs = []
        for root, _dirs, files in os.walk(directory_path):
            all_dirs.append(root)

        # Ensure we include directories that had files but weren't under
        # directory_path (unlikely) â€” clamp to those under directory_path.
        all_dirs = sorted(set(all_dirs))

        # Compute recursive totals by processing deeper paths first
        all_dirs_sorted = sorted(
            all_dirs, key=lambda p: p.count(os.sep), reverse=True)
        dir_recursive = {}
        dir_recursive_possible = {}
        for d in all_dirs_sorted:
            own = dir_own.get(d, 0)
            own_pos = dir_own_possible.get(d, 0)
            # sum totals of any child directories (already computed)
            child_sum = 0
            child_sum_pos = 0
            for child, total in dir_recursive.items():
                if child.startswith(d + os.sep):
                    child_sum += total
                    child_sum_pos += dir_recursive_possible.get(child, 0)
            dir_recursive[d] = own + child_sum
            dir_recursive_possible[d] = own_pos + child_sum_pos

        # Write summary CSV into the top-level directory_path
        summary_path = os.path.join(directory_path, SUMMARY_FILE_NAME)
        try:
            with open(summary_path, 'w', encoding='utf-8') as csvf:
                print(f"Writing summary CSV to '{summary_path}'")
                csvf.write('Directory,TotalObtained,TotalPossible\n')
                # Write rows sorted by directory path for deterministic output
                for d in sorted(all_dirs):
                    # Use relative directory path from the top-level to keep CSV readable
                    rel = os.path.relpath(d, directory_path)
                    if rel == '.':
                        rel = os.path.basename(directory_path) or '.'
                    csvf.write(
                        f"{rel},{dir_recursive.get(d, 0)},{dir_recursive_possible.get(d, 0)}\n")
        except OSError as e:
            print(f"Could not write summary CSV to '{summary_path}': {e}")
    else:
        print(
            f'Not writing summary CSV (either not recursive or write_summary is False): recursive={recursive}, write_summary={write_summary}')

    if report_per_file:
        return total_obtained, total_possible, per_file_results
    return total_obtained, total_possible


def single_file_demo():
    """
    Demonstrate grading comment extraction and score computation on a single file.
    """
    comments = extract_grading_comments_from_file(
        r"C:\Users\jmac\claude\assemble-grading-comments\Elian Vera_1276956_assignsubmission_file\circles_graded.py")
    for comment in comments:
        print(comment)
    # Demonstrate the new score-summing function
    obtained, possible = compute_score_totals(comments)
    print(f"Total obtained: {obtained} / Total possible: {possible}")


def directory_demo(directory_path, recursive=False, report_per_file=False, write_report=False, write_summary=False):
    """
    Demonstrate scanning a directory of .py files and computing totals.

    If report_per_file is True, the demo will also print per-file totals.
    """
    if report_per_file:
        result = compute_totals_in_directory(
            directory_path, recursive=recursive, report_per_file=True, write_report=write_report, write_summary=write_summary
        )
        if isinstance(result, tuple) and len(result) == 3:
            obtained = result[0]
            possible = result[1]
            per_file = result[2]
        else:
            # Fallback if implementation changes unexpectedly
            obtained = result[0]
            possible = result[1]
            per_file = {}
        print(
            f"Directory totals for '{directory_path}' (recursive={recursive}): {obtained} / {possible}")
        print("Per-file breakdown:")
        for path, val in sorted(per_file.items()):
            # val may be either (obt, pos) or (comments_list, (obt, pos))
            if isinstance(val, tuple) and len(val) == 2 and isinstance(val[1], tuple):
                obt, pos = val[1]
            elif isinstance(val, tuple) and len(val) == 2:
                obt, pos = val
            else:
                # Fallback
                obt, pos = 0, 0
            print(f"  {path}: {obt} / {pos}")
    else:
        obtained, possible = compute_totals_in_directory(
            directory_path, recursive=recursive, report_per_file=False, write_report=write_report, write_summary=write_summary
        )
        print(
            f"Directory totals for '{directory_path}' (recursive={recursive}): {obtained} / {possible}")


if __name__ == "__main__":
    # Run the single-file demo
    # single_file_demo()

    # Example directory demos: change the paths to folders you want to scan.
    # Set report_per_file=True to enable per-file debugging output.
    # Example: enable per-file printing but don't write report files
    # directory_demo(r"C:\Users\jmac\claude\assemble-grading-comments\Dylan Elder_1276949_assignsubmission_file", recursive=False, report_per_file=True, write_report=False)
    # Example: enable per-file printing and write report files to each directory
    # directory_demo(r"C:\Users\jmac\claude\assemble-grading-comments\Elian Vera_1276956_assignsubmission_file", recursive=False, report_per_file=True, write_report=True)

    directory_demo(r"C:\Users\jmac\claude\assemble-grading-comments",
                   recursive=True, report_per_file=True, write_report=True, write_summary=True)
